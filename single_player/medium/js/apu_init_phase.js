/**
 * Matrix transpose function credited to stackoverflow user troynt
 * http://stackoverflow.com/a/4492703
 */
transpose = function(a) {

  // Calculate the width and height of the Array
  var w = a.length ? a.length : 0,
    h = a[0] instanceof Array ? a[0].length : 0;

  // In case it is a zero matrix, no transpose routine needed.
  if(h === 0 || w === 0) { return []; }

  /**
   * @var {Number} i Counter
   * @var {Number} j Counter
   * @var {Array} t Transposed data is stored in this array.
   */
  var i, j, t = [];

  // Loop through every item in the outer array (height)
  for(i=0; i<h; i++) {

    // Insert a new row (array)
    t[i] = [];

    // Loop through every item per item in outer array (width)
    for(j=0; j<w; j++) {

      // Save transposed data.
      t[i][j] = a[j][i];
    }
  }

  return t;
};

/**
 * Finds next non-'.' element in `Sequence`, starting from `Start` to `Limit`
 * @param   {Array(String)}     Array of strings generated by game
 * @param   {Int}               Starting index
 * @param   {Int}               Limiting value, often length of `Sequence`
 * @return  Index of non-'.' element in `Sequence`, -1 if it doesn't exist
 */
function find(Sequence, Start, Limit) {
    if (typeof Sequence != 'undefined') {
        for (var i = Start; i < Limit; i++) {
            if (Sequence[i] != '.') {
                printErr('found... ' + i);
                return i;
            }
        }
    }
    return -1;
};

/**
 * --- Begin game input ---
 */

var width   = parseInt(readline()), // Width of game board
    height  = parseInt(readline()), // Height of game board
    matrix  = new Array(),          // Stores matrix
    x1 = 0, // Root node X
    y1 = 0, // Root node Y
    x2 = 0, // Right neighbour node X
    y2 = 0, // Right neighbour node Y
    x3 = 0, // Bottom neighbour node X
    y3 = 0; // Bottom neighbour node Y

/**
 * Read all matrix rows, split them, and push them into `matrix`.
 */
for (var i = 0; i < height; i++) {
    var line = readline().split('');
    matrix.push(line);
}

/**
 * Transpose matrix for easier traversal along y-axis
 */
var tmatrix = transpose(matrix);

/**
 * Beginning with the top left element of the matrix, search for
 * valid root node. If a valid node was found (not -1), use the
 * adjust the for loop's current X position on the matrix to
 * valid node's X position. Search for neighbours if valid root
 * node was found. Print coordinates.
 */
for (var i = 0; i < height; i++) {
    for (var j = 0; j < width; j++) {
        x1 = find(matrix[i], j, width);
        if (x1 !== -1) {
            y1 = i;
            j = x1;
            x2 = find(matrix[i], x1+1, width);
            y2 = y1;
            x3 = x1;
            y3 = find(tmatrix[j], y1+1, height);
            print(x1 + ' ' + y1 + ' ' + x2 + ' ' + y2 + ' ' + x3 + ' ' + y3);
        }
    }
}

/**
 * TODO: Optimise! After a root node and its neighbours are found,
 * the next root node should be set to the first right neighbour
 * that was found. If no right neighbour exists, next root node
 * should be first bottom neighbour that was found. This prevents
 * unnecessary computational cycles because matrix indexes of
 * invalid nodes are passed over.
 */
